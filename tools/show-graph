#!/usr/bin/env python3

# Software Name : uprofile
# SPDX-FileCopyrightText: Copyright (c) 2022 Orange
# SPDX-License-Identifier: BSD-3-Clause
#
# This software is distributed under the BSD License;
# see the LICENSE file for more details.
#
# Author: CÃ©dric CHEDALEUX <cedric.chedaleux@orange.com> et al.


import argparse
import plotly.figure_factory as ff
from plotly.subplots import make_subplots
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd


def read(csv_file):
    """
    Generate a DataFrame from the CSV file
    Metrics event can have up to 3 extra parameters in addition to its type and its timestamp
    :param csv_file:
    :return: Dataframe
    """
    return pd.read_csv(csv_file, sep=';', names=['metric', 'timestamp', 'extra_1', 'extra_2', 'extra_3'])


def filter_dataframe(df, metric):
    """
    Filter the datafram by metric type
    :param df:
    :param metric:
    :return: Dataframe
    """
    return df[df['metric'] == metric]


def gen_time_exec_df(df):
    """
    Format the dataframe to represent time exec data as gant tasks
    :param df:
    :return: dataframe with gant tasks
    """
    if df.empty:
        return None
    # 'time_exec' format is 'time_exec:<end_timestamp>:<start_timestamp>:<task_name>')
    time_exec_df = df[['extra_2', 'extra_1', 'timestamp']].copy()
    time_exec_df.rename(columns={"extra_2": "Task", "extra_1": "Start", "timestamp": "Finish"}, inplace=True)
    time_exec_df['Description'] = time_exec_df.apply(lambda row: "Task: {} (duration = {} ms)"
                                                     .format(row['Task'], int(row['Finish']) - int(row['Start'])),
                                                     axis=1)
    time_exec_df['Start'] = pd.to_datetime(time_exec_df['Start'], unit='ms')
    time_exec_df['Finish'] = pd.to_datetime(time_exec_df['Finish'], unit='ms')
    return time_exec_df


def create_gantt_graph(df):
    """
    Create a gant graph to represent the tasks
    (see https://chart-studio.plotly.com/~empet/15242/gantt-chart-in-a-subplot-httpscommun/ and https://plotly.com/python/gantt/)
    :param df:
    :return: graph
    """
    size = len(df['Start'])
    colors = px.colors.sample_colorscale("turbo", [n / (size - 1) for n in range(size)])
    return ff.create_gantt(df, colors=colors, show_colorbar=True, showgrid_x=True, showgrid_y=True,
                           show_hover_fill=True)


def create_cpu_graphs(df):
    if df.empty:
        return None
    # 'cpu' metrics (format is 'cpu:<timestamp>:<cpu_number>:<percentage_usage>')
    cpus = pd.unique(df['extra_1'])
    for cpu in cpus:
        cpu_df = df[df['extra_1'] == cpu]
        yield go.Scatter(x=pd.to_datetime(cpu_df['timestamp'], unit='ms'),
                         y=pd.to_numeric(cpu_df['extra_2']),
                         name="CPU {}".format(cpu),
                         showlegend=True)


def create_sys_mem_graphs(df):
    # 'sys_mem' metrics (format is 'mem:<timestamp>:<total>:<available>:<free>')
    if df.empty:
        return None

    names = ["Total", "Available", "Free"]
    for index in range(3):
        yield go.Scatter(x=pd.to_datetime(df['timestamp'], unit='ms'),
                         y=(pd.to_numeric(df["extra_{}".format(index + 1)], downcast="integer") / 1000),
                         name=names[index],
                         showlegend=True)


def create_proc_mem_graphs(df):
    # 'proc_mem' metrics (format is 'mem:<timestamp>:<rss>:<shared>')
    if df.empty:
        return None

    names = ["RSS", "Shared"]
    for index in range(2):
        yield go.Scatter(x=pd.to_datetime(df['timestamp'], unit='ms'),
                         y=(pd.to_numeric(df["extra_{}".format(index + 1)], downcast="integer") / 1000),
                         name=names[index],
                         showlegend=True)


def main():
    """
    Show the duration task graph and the cpu usage graph on a single view
    The tools reads the metrics file generated by the uprofile library
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('INPUT_FILE', type=str, help='Input file that contains profiling data')
    parser.add_argument('--output', '-o', type=str,
                        help='Save the graph to the given HTML file')
    args = parser.parse_args()

    if args.INPUT_FILE is None:
        parser.error('no INPUT_FILE given')

    # Use a multiple subplots (https://plotly.com/python/subplots/) to display
    # - the duration task graph
    # - the CPU usage
    # - the memory usage (system and process)
    figs = make_subplots(rows=4,
                         cols=1,
                         shared_xaxes=True,
                         row_heights=[0.5, 0.2, 0.15, 0.15],
                         vertical_spacing=0.025,
                         subplot_titles=(
                             "Execution graph", "CPU load", "System Memory (in MB)", "Process Memory (in MB)")
                         )

    with open(args.INPUT_FILE) as file:
        global_df = read(file)

        # Display a grant graph for representing task execution durations
        time_exec_df = gen_time_exec_df(filter_dataframe(global_df, 'time_exec'))
        if time_exec_df is not None:
            for trace in create_gantt_graph(time_exec_df).data:
                figs.add_trace(trace, row=1, col=1)

        # Display all CPU usages in the same graph
        for trace in create_cpu_graphs(filter_dataframe(global_df, 'cpu')):
            figs.add_trace(trace, row=2, col=1)

        # Display memory usage
        for trace in create_sys_mem_graphs(filter_dataframe(global_df, 'sys_mem')):
            figs.add_trace(trace, row=3, col=1)
        figs.update_yaxes(row=3, col=1, rangemode="tozero")

        # Display process memory usage
        for trace in create_proc_mem_graphs(filter_dataframe(global_df, 'proc_mem')):
            figs.add_trace(trace, row=4, col=1)
        figs.update_yaxes(row=4, col=1, rangemode="tozero")

        figs.update_layout(
            height=1200,
            xaxis_tickformat='%M:%S',
            showlegend=False
        )

        figs.show()

        if args.output is not None:
            print("Saving graph to '{}'".format(args.output))
            figs.write_html(args.output)


if __name__ == '__main__':
    main()
